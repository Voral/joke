# Конфигурация

Фреймворк Joke предоставляет гибкую и типобезопасную систему конфигурации, состоящую из двух уровней: переменных
окружения (`.env`) для чувствительных данных и настроек среды, и объектных конфигурационных файлов для структуры
приложения.

## 1. Конфигурация окружения

Для управления настройками, зависящими от среды выполнения (разработка, тестирование, продакшен), Joke использует `.env`
-файлы.

### Определение текущего окружения

Текущее окружение определяется автоматически из следующих источников (в порядке убывания приоритета):

1. Переменная `$_ENV['JK_ENV']`
2. Переменная `$_SERVER['JK_ENV']`
3. Системная переменная окружения `getenv('JK_ENV')`

Если переменная не задана ни в одном из источников, по умолчанию используется окружение **`local`**.

### Стандартные наименования окружений

В фреймворке предусмотрены константы для стандартных сред:

* `Environment::ENV_PRODUCTION` (`'production'`) — продуктовое окружение.
* `Environment::ENV_DEVELOPMENT` (`'development'`) — окружение для разработки.
* `Environment::ENV_TESTING` (`'testing'`) — тестовое окружение.
* `Environment::ENV_LOCAL` (`'local'`) — локальное окружение по умолчанию.

### Порядок загрузки .env-файлов

Система загружает файлы последовательно, позволяя последующим файлам переопределять значения предыдущих:

1. **`.env`** — базовый файл, общий для всех окружений.
2. **`.env.{JK_ENV}`** — специфичный файл для текущей среды (например, `.env.production`, `.env.development`).
    * *Исключение:* Файл `.env.local` не загружается по этому шаблону.
3. **`.env.local`** — файл для локальных переопределений разработчика.
    * Загружается **всегда последним**, перезаписывая любые предыдущие значения.
    * *Исключение:* Не загружается, если текущее окружение — `testing` (чтобы тесты были предсказуемыми и не зависели от
      локальных настроек).

> **Важно!**
> Никогда не коммитьте файлы `.env` и `.env.local`, содержащие секреты (пароли, ключи API), в систему контроля версий.
> Используйте файл `.env.example` как шаблон для других разработчиков.

### Поддерживаемые типы значений

Парсер `.env` файлов автоматически преобразует строковые значения в соответствующие типы PHP:

| Запись в .env          | Тип в PHP | Описание                    |
|:-----------------------|:----------|:----------------------------|
| `PROP=1`               | `int`     | Целое число                 |
| `PROP=1.2`             | `float`   | Число с плавающей точкой    |
| `PROP=1e2`, `PROP=1E2` | `float`   | Научная нотация             |
| `PROP=true`            | `bool`    | Логическое true             |
| `PROP=false`           | `bool`    | Логическое false            |
| `PROP=null`, `PROP=`   | `null`    | Null значение               |
| `PROP`                 | `null`    | Ключ без значения           |
| `PROP=Hello`           | `string`  | Строка                      |
| `PROP="Hello"`         | `string`  | Строка в двойных кавычках   |
| `PROP='Hello'`         | `string`  | Строка в одинарных кавычках |

**Экранирование:** В строках, обрамленных кавычками, поддерживается экранирование специальных символов:

* `PROP="Hello \"world\""` → `Hello "world"`
* `PROP='Hello \'world\''` → `Hello 'world'`

---

## 2. Конфигурационные файлы

Для сложных настроек, требующих типизации и структуры, Joke использует PHP-файлы, возвращающие объекты конфигураций. Эти
файлы дополняют `.env` и позволяют организовать настройки в удобном объектно-ориентированном виде.

### Типы конфигурационных файлов

Существует три типа конфигов, различающихся временем загрузки:

#### 2.1. Конфигурация ядра (Kernel Config)

Загружается самой первой, до инициализации основных сервисов. Определяет поведение самого ядра фреймворка.

* **Расположение:** `bootstrap/kernel.php`.
* **Поведение:** Если файл отсутствует, используются настройки по умолчанию.
* **Формат:** Должен возвращать объект класса `Vasoft\Joke\Application\KernelConfig`.

**Пример `bootstrap/kernel.php`:**

```php
<?php
/** @var \Vasoft\Joke\Config\Environment $env */

use Vasoft\Joke\Application\KernelConfig;
use Vasoft\Joke\Logging\Handlers\StreamHandler;
use Vasoft\Joke\Logging\LogLevel;
use Vendor\Project\Providers;
use Vasoft\Joke\Logging\Logger;

$loggerHandlers = [
    new StreamHandler($env->getBasePath().'error.log'),
    new StreamHandler($env->getBasePath().'info.log', LogLevel::INFO, LogLevel::INFO),
];

return new KernelConfig()
    ->addProvider(Providers\CustomProvider::class)
    ->addDeferredProvider(Providers\ExampleProvider::class)
    ->setBaseConfigPath('config')
    ->addLazyConfigPath('config/lazy')
    ->setLogger(static fn() => new Logger($loggerHandlers]));
```

#### 2.2. Базовые конфигурации (Eager Loading)

Загружаются сразу при старте приложения путем сканирования указанной директории.

* **Расположение:** По умолчанию каталог `config` (путь настраивается в `KernelConfig`).
* **Именование:** Произвольное (например, `database.php`, `mail.php`).

#### 2.3. Отложенные конфигурации (Lazy Loading)

Загружаются только в момент первого обращения к конкретному классу конфигурации. Это ускоряет старт приложения,
откладывая создание тяжелых объектов.

* **Расположение:** По умолчанию каталог `config/lazy` (путь настраивается в `KernelConfig`).
* **Именование:** Имя файла должно совпадать с **коротким именем класса** (без неймспейса) и иметь расширение `.php`.
    * Пример: Для классов `Vendor\Project\Config\FirstConfig` и `SecondVendor\Project\Config\FirstConfig` имя файла
      будет общим — `FirstConfig.php`.
* **Разрешение коллизий:** Один файл может содержать определения для нескольких классов с одинаковым коротким именем, но
  из разных неймспейсов. При первом запросе любого из них файл загружается один раз, и регистрируются все найденные в
  нем классы.

### Формат файлов конфигурации

Файлы базовых и отложенных конфигураций могут возвращать:

1. **Одиночный объект:** Экземпляр класса, наследующего `Vasoft\Joke\Config\AbstractConfig`.
2. **Ассоциативный массив:** Где ключ — полное имя класса (`class-string`), а значение — экземпляр `AbstractConfig` или
   замыкание (`Closure`), возвращающее его.

> **Доступ к переменным окружения**
> В область видимости каждого конфигурационного файла автоматически передается экземпляр класса `Environment` через
> переменную `$env`. Это позволяет безопасно читать значения из `.env` без глобальных функций.

**Пример базового файла `config/events.php`:**

```php
<?php
/** @var \Vasoft\Joke\Config\Environment $env */

use Vendor\Project\Config\FirstConfig;
use Vendor\Project\Config\SecondConfig;

return [
    // Замыкание для отложенной инициализации внутри базового файла
    FirstConfig::class => static fn() => new FirstConfig(),
    
    // Мгновенная инициализация с использованием $env
    SecondConfig::class => new SecondConfig($env->get('APP_NAME')),
];
```

**Пример файла отложенной конфигурации `config/lazy/FirstConfig.php`:**

```php
<?php
/** @var \Vasoft\Joke\Config\Environment $env */

use Vendor\Project\Config\FirstConfig;
use SecondVendor\Project\Config\FirstConfig as OtherFirstConfig;

// Один файл обслуживает два класса с одинаковым коротким именем
return [
    FirstConfig::class => static fn() => new FirstConfig(),
    OtherFirstConfig::class => static fn() => new OtherFirstConfig($env->get('API_KEY')),
];
```

---

### Доступ к конфигурации

Все конфигурации после создания становятся иммутабельными (только для чтения). Благодаря глубокой интеграции
`ConfigManager` в механизм автоматического внедрения зависимостей (Autowiring), доступ к ним осуществляется максимально
просто.

#### Способ 1: Автоматическое внедрение (Рекомендуемый)

Вам не нужно явно вызывать менеджер. Просто укажите нужный класс конфигурации в типизированном аргументе конструктора
контроллера или сервиса.

```php
use Vendor\Project\Config\FirstConfig;

class MyController
{
    public function __construct(
        private FirstConfig $config // Типизированная зависимость
    ) {}

    public function index(): string
    {
        return $this->config->getValue();
    }
}
```

**Как это работает под капотом:**
Компонент разрешения зависимостей (`ParameterResolver`) при создании объекта выполняет следующий алгоритм:

1. **Поиск в реестре:** Проверяет, есть ли сервис типа `FirstConfig` в контейнере. Если да — возвращает его.
2. **Проверка на конфиг:** Если сервис не найден, проверяет, является ли класс наследником `AbstractConfig`.
    * **Если ДА:** Автоматически обращается к `ConfigManager` через `$container->get(ConfigManager::class)` и вызывает
      `$manager->get(FirstConfig::class)`.
        * Менеджер ищет файл в папке lazy, загружает его, регистрирует найденные конфиги и возвращает экземпляр.
        * *(Опционально)* Если файл не найден, запрашивает дефолтное значение у сервис-провайдеров.
    * **Если НЕТ:** Выбрасывает исключение `AutowiredException`.

> **Преимущества:**
> * **Прозрачность:** Вы работаете только с типами, не думая о физическом расположении конфига.
> * **Ленивость:** Файл считывается только если класс реально потребовался.
> * **Безопасность типов:** Гарантия получения объекта нужного класса.

#### Способ 2: Явный доступ через ConfigManager

Используется в случаях, когда автовиринг недоступен (статические методы, глобальная область видимости).

```php
use Vasoft\Joke\Config\ConfigManager;

/** @var \Vasoft\Joke\Container\ServiceContainer $container */
$manager = $container->get(ConfigManager::class);
$config = $manager->get(Vendor\Project\Config\FirstConfig::class);
```

---

### Создание собственных конфигураций

Все классы конфигураций должны наследовать `Vasoft\Joke\Config\AbstractConfig`. Для защиты от случайного изменения
настроек в рантайме рекомендуется использовать механизм **«замораживания»**.

Вызывайте метод `$this->guard()` в сеттерах. Он выбросит исключение, если попытка изменения произойдет после завершения
инициализации приложения.

Пример:

```php
namespace Vendor\Configs;

use Vasoft\Joke\Config\AbstractConfig;

class MyConfig extends AbstractConfig
{
    private int $someValue = 0;
    
    public function setSomeValue(int $value): self 
    {
        $this->guard(); // Защита от записи
        $this->someValue = $value;
        return $this;
    } 

    public function getSomeValue(): int 
    {
        return $this->someValue;
    } 
}
```
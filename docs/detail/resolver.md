# Резолвер зависимостей

`Vasoft\Joke\Core\Routing\ParameterResolver` — это компонент, отвечающий за **автоматическое связывание параметров** при вызове callable-значений (обработчиков маршрутов, middleware, фабрик) и создании объектов через конструктор. Он объединяет данные из **контекста запроса** (например, параметров URI) и **DI-контейнера**, обеспечивая гибкое и типобезопасное внедрение зависимостей.

Резолвер реализует интерфейс `Vasoft\Joke\Contract\Core\Routing\ResolverInterface` и интегрирован во все ключевые части фреймворка: маршрутизацию, DI-контейнер и middleware.

## Принцип работы

При разрешении параметров резолвер следует строгому порядку:

1. **Сначала проверяется контекст**  
   Если имя параметра совпадает с ключом в массиве `$context` (например, `{id}` из маршрута `/user/{id}`), значение берётся оттуда.

2. **Затем — DI-контейнер**  
   Если параметр не найден в контексте, но имеет типизацию объекта, резолвер запрашивает его у DI-контейнера.

3. **Автоматическая десериализация**  
   Если параметр из контекста имеет тип класса, поддерживающего `tryFrom()` (например, enum), вызывается этот метод для преобразования скалярного значения в объект.

>  Если параметр не может быть разрешён ни из контекста, ни из контейнера — выбрасывается `AutowiredException`.

## Поддерживаемые сценарии

### 1. Параметры из контекста (маршруты, middleware)

```php
$router->get('/order/{status}', function (OrderStatus $status) {
    // $status = OrderStatus::tryFrom($context['status'])
});
```

- Значение `status` извлекается из URI,
- Автоматически преобразуется через `OrderStatus::tryFrom()`.

### 2. Внедрение сервисов из DI-контейнера

```php
function handle(UserRepository $users, Logger $log) {
    // $users = $container->get(UserRepository::class)
    // $log = $container->get(Logger::class)
}
```

### 3. Смешанный случай

```php
$router->get('/user/{id:int}', function (int $id, UserRepository $users) {
    // $id — из URI, $users — из контейнера
});
```

## API резолвера

### `resolveForCallable(callable|string|array $callable, array $context = [])`

Анализирует сигнатуру функции, метода или замыкания и возвращает массив аргументов, готовых к передаче через `...$args`.

Поддерживает все формы callable:
- Замыкания: `fn() => ...`
- Строки: `'MyClass::method'`
- Массивы: `[MyClass::class, 'method']`

### `resolveForConstructor(string $className, array $context = [])`

Анализирует конструктор класса и возвращает аргументы для его вызова. Если конструктор отсутствует — возвращает пустой массив.

## Обработка ошибок

Если параметр не может быть разрешён, выбрасывается:

```php
Vasoft\Joke\Core\Routing\Exceptions\AutowiredException
```

Пример сообщения:
> `Failed to autowire parameter "$status": expected type "OrderStatus" cannot be resolved or is incompatible with the provided value.`

Это помогает быстро выявлять:
- незарегистрированные сервисы,
- некорректные значения в URI,
- отсутствие `tryFrom` у запрошенного класса


## Особенности и ограничения

- **Порядок приоритетов**: контекст > DI-контейнер.
- **Типобезопасность**: только классы с `tryFrom()` могут преобразовываться из скалярных значений.
- **Нет поддержки параметров по умолчанию** (планируется в будущем).
- **Рефлексия не кэшируется** — в целях простоты (оптимизация возможна в будущих версиях).

## Интеграция с фреймворком

Резолвер автоматически используется в:
- **DI-контейнере** — при создании сервисов и вызове фабрик,
- **Маршрутизаторе** — при вызове обработчиков маршрутов,
- **Middleware** — при создании экземпляров через DI.

Вы можете получить доступ к нему напрямую через контейнер:

```php
$resolver = $container->getParameterResolver();
$args = $resolver->resolveForCallable(fn(UserService $u) => ..., ['custom' => 'value']);
```

## Замена резолвера

По умолчанию Joke использует `Vasoft\Joke\Core\Routing\ParameterResolver`, но вы можете **полностью заменить его своей реализацией**, если требуется кастомная логика разрешения параметров (например, поддержка параметров по умолчанию, кэширование рефлексии или интеграция с внешними источниками данных).

Для этого зарегистрируйте свой класс как реализацию `ResolverInterface` в DI-контейнере **до создания приложения**:

```php
// bootstrap/app.php
$container = new ServiceContainer();
$container->registerSingleton(
    ResolverInterface::class,
    MyCustomParameterResolver::class
);

return new Application(dirname(__DIR__), 'routes/web.php', $container);
```

>  Убедитесь, что ваш резолвер:
> - реализует `Vasoft\Joke\Contract\Core\Routing\ResolverInterface`,
> - принимает `ServiceContainer` в конструкторе (если нужен доступ к DI),
> - корректно обрабатывает контекст и типы параметров.

После регистрации новый резолвер будет использоваться **везде**: при создании сервисов, вызове обработчиков маршрутов и middleware.
